<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="author" content="8090Lambert"><meta name="google-site-verification" content="NlVkPYQIz-6FEWSYj-zlvN-gVromFNmq2v7hUK_WyyM"><meta name="sogou_site_verification" content="GFRFxFpBEM"><meta property="og:title" content="sync.Pool原理解析"><meta property="og:description" content="A Programmer With Coding."><meta property="og:site_name" content="8090Lambert | Blog"><meta property="og:type" content="article"><meta property="og:image" content="http://8090lambert.cn"><link rel="alternate" href="/atom.xml" title="8090Lambert | Blog" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><title>8090Lambert | Blog</title><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-146263529-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script>var _hmt=_hmt||[]</script><script async src="//hm.baidu.com/hm.js?dfc9714182f4393d85cb19cc7ad9c231"></script></head><body><nav class="navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="collapse navbar-collapse site-menu"><ul class="nav navbar-nav navbar-right"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/about">About</a></li><li> <a href="mailto:<juzs215@gmail.com>">Email</a></li><li><a href="https://github.com/8090Lambert"><i class="icon fa fa-github fa-lg"></i></a></li></ul></div></div></nav><header class="site-header header-background intro-header" style="background-image:url(/img/banner.jpg)"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="page-title with-background-image"><p class="title">sync.Pool原理解析</p><p class="subtitle"></p></div></div></div></div></header><article><div class="container typo"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-info text-muted"> <span class="author info">By 8090Lambert</span> <span class="date-time info">On <span class="date">2021-05-23T18:34:06+08:00</span></span></div><div class="post-tags text-muted"> Tags: <a class="tag" href="/tags/go/">#go</a></div><div class="post-content"><h2 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h2><p><img src="https://s.im5.me/2021/05/18/AoiUM.png" alt="Pool"></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>拥有垃圾回收特性的语言里，gc发生时都会带来性能损耗，为了减少gc影响，通常的做法是减少小块对象内存频繁申请，让每次发生垃圾回收时scan和clean活跃对象尽可能的少。<code>sync.Pool</code>可以帮助在程序构建了对象池，提供对象可复用能力，本身是可伸缩且并发安全的。</p><p>主要结构体<code>Pool</code>对外导出两个方法： <code>Get</code> 和 <code>Put</code>，<strong>Get是用来从Pool中获取可用对象</strong>，如果可用对象为空，则会通过<code>New</code>预定义的func创建新对象。<strong>Put是将对象放入Pool中，提供下次获取</strong>。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf89ea28650543e08402ab0f8c8b6ed6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><pre><code>func (p *Pool) Get() interface{} {
    if race.Enabled {
        race.Disable()
    }
    l, pid := p.pin()
    x := l.private
    l.private = nil
    if x == nil {
        // Try to pop the head of the local shard. We prefer
        // the head over the tail for temporal locality of
        // reuse.
        x, _ = l.shared.popHead()
        if x == nil {
            x = p.getSlow(pid)
        }
    }
    runtime_procUnpin()
    if race.Enabled {
        race.Enable()
        if x != nil {
            race.Acquire(poolRaceAddr(x))
        }
    }
    if x == nil &amp;&amp; p.New != nil {
        x = p.New()
    }
    return x
}
</code></pre><p>首先看下<code>GET</code>方法的逻辑（在看前需要对<code>gmp</code>调度模型有大致了解）</p><ul><li>通过<code>pin</code>拿到<code>poolLocal</code>和当前 goroutine 绑定运行的<code>P</code>的 id。每个goroutine创建后会挂在<code>P</code>结构体上；运行时，需要绑定<code>P</code>才能在<code>M</code>上执行。因此，对private指向的poolLocal操作无需加锁，都是线程安全的</li><li>设置<code>x</code>，并且清空<code>private</code></li><li><code>x</code>为空说明本地对象未设置，由于<code>P</code>上存在多个<code>G</code>，如果一个时间片内协程1把私有对象获取后置空，下一时间片g2再去获取就是nil。此时需要去<code>share</code>中获取头部元素，<code>share</code>是在多个<code>P</code>间共享的，读写都需要<code>加锁</code>，但是这里并未加锁，具体原因等下讲</li><li>如果<code>share</code>中也返回空，调用<code>getSlow()</code>函数获取，等下具体看内部实现</li><li>runtime_procUnpin()方法，稍后我们详细看</li><li>最后如果还是未找到可复用的对象, 并且设置了<code>New</code>的func，初始化一个新对象</li></ul><p><code>Pool</code>的<code>local</code>字段表示<code>poolLocal</code>指针。获取时，优先检查<code>private</code>域是否为空，为空时再从<code>share</code>中读取，还是空的话从其他<code>P</code>中窃取一个，类似<code>goroutine</code>的调度机制。</p><h3 id="pin"><a href="#pin" class="headerlink" title="pin"></a>pin</h3><p>刚才的几个问题，我们具体看下。首先，<code>pin</code>方法获取当前<code>P</code>的<code>poolLocal</code>,方法逻辑比较简单</p><pre><code>func (p *Pool) pin() *poolLocal {
    pid := runtime_procPin()
    s := atomic.LoadUintptr(&amp;p.localSize) // load-acquire
    l := p.local                          // load-consume
    if uintptr(pid) &lt; s {
        return indexLocal(l, pid)
    }
    return p.pinSlow()
}
</code></pre><p><code>runtime_procPin</code>返回了当前的pid，实现细节看看<code>runtime</code>内部</p><pre><code>//go:linkname sync_runtime_procPin sync.runtime_procPin
//go:nosplit
func sync_runtime_procPin() int {
    return procPin()
}
//go:linkname sync_runtime_procUnpin sync.runtime_procUnpin
//go:nosplit
func sync_runtime_procUnpin() {
    procUnpin()
}
//go:nosplit
func procPin() int {
    _g_ := getg()
    mp := _g_.m

    mp.locks++
    return int(mp.p.ptr().id)
}
//go:nosplit
func procUnpin() {
    _g_ := getg()
    _g_.m.locks--
}
</code></pre><ul><li><code>pin</code>获取当前goroutine的地址，让g对应的<code>m</code>结构体中<code>locks</code>字段++，返回<code>p</code>的id。<code>unPin</code>则是对<code>m</code>的<code>locks</code>字段–，为什么要这么做？</li></ul><p>协程发生调度的时机之一：如果某个g长时间占用cpu资源，便会发生抢占式调度，可以抢占的依据就是locks == 0。<strong>其实本质是为了禁止发生抢占。</strong></p><pre><code>// One round of scheduler: find a runnable goroutine and execute it.
// Never returns.
func schedule() {
    _g_ := getg()

    //调度时，会判断`locks`是否为0。
    if _g_.m.locks != 0 {
        throw(&quot;schedule: holding locks&quot;)
    }
    ...
}
</code></pre><p>为什么要禁止调度呢?因为调度是把<code>m</code>和<code>p</code>的绑定关系解除，让<code>p</code>去绑定其他线程，执行其他线程的代码段。在<code>get</code>时，首先是获取当前goroutine绑定的p的private，不禁止调度的话，后面的获取都不是当前协程的运行时的<code>p</code>，会污染其他<code>p</code>上的数据，引起未知错误。</p><h4 id="poolChain"><a href="#poolChain" class="headerlink" title="poolChain"></a>poolChain</h4><p><code>poolChain</code>是一个双端链表，结构体如下：</p><pre><code>type poolChain struct {
    head *poolChainElt
    tail *poolChainElt
}
</code></pre><h4 id="poolChain-popHead"><a href="#poolChain-popHead" class="headerlink" title="poolChain.popHead"></a>poolChain.popHead</h4><p><code>poolChain.popHead</code>获取时，首先从<code>poolDequeue</code>的<code>popHead</code>方法获取，未获取到时，找到<code>prev</code>节点，继续重复查找，直到返回nil。</p><pre><code>func (c *poolChain) popHead() (interface{}, bool) {
    d := c.head
    for d != nil {
        if val, ok := d.popHead(); ok {
            return val, ok
        }
        // There may still be unconsumed elements in the
        // previous dequeue, so try backing up.
        d = loadPoolChainElt(&amp;d.prev)
    }
    return nil, false
}
</code></pre><p><strong><em>这里注意区分<code>poolChain</code>和<code>poolDequeue</code>，两个结构存在同名的方法，但是结构和逻辑完全不同</em></strong></p><pre><code>type poolChain struct {
    // head is the poolDequeue to push to. This is only accessed
    // by the producer, so doesn&#39;t need to be synchronized.
    head *poolChainElt

    // tail is the poolDequeue to popTail from. This is accessed
    // by consumers, so reads and writes must be atomic.
    tail *poolChainElt
}
type poolChainElt struct {
    poolDequeue
    next, prev *poolChainElt
}
type poolDequeue struct {
    headTail uint64
    vals []eface
}
</code></pre><p>需要说明下：<code>poolChainElt</code>组成的链表结构和我们常见的链表方向相反，从<code>head</code> -&gt; <code>tail</code>的方向是<code>prev</code>，反之是<code>next</code>;<code>poolDequeue</code> 是一个环形链表，<code>headTail</code>字段保存首尾地址，其中高32位表示head，低32位表示tail.</p><h4 id="poolDequeue-popHead"><a href="#poolDequeue-popHead" class="headerlink" title="poolDequeue.popHead"></a>poolDequeue.popHead</h4><pre><code>func (d *poolDequeue) popHead() (interface{}, bool) {
    var slot *eface
    for {
        ptrs := atomic.LoadUint64(&amp;d.headTail)
        head, tail := d.unpack(ptrs)
        if tail == head {
            return nil, false
        }
        head--
        ptrs2 := d.pack(head, tail)
        if atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) {
            slot = &amp;d.vals[head&amp;uint32(len(d.vals)-1)]
            break
        }
    }

    val := *(*interface{})(unsafe.Pointer(slot))
    if val == dequeueNil(nil) {
        val = nil
    }
    *slot = eface{}
    return val, true
}
</code></pre><ul><li>看到<code>if tail == head</code>，如果首位地址相同说明链表整体为空，证明<code>poolDequeue</code>确实是环形链表；</li><li><code>head--</code>后<code>pack(head, tail)</code>得到新的地址ptrs2，如果ptrs == ptrs2，修改<code>headTail</code>地址；</li><li>把slot转成interface{}类型的value；</li></ul><h3 id="getSlow"><a href="#getSlow" class="headerlink" title="getSlow"></a>getSlow</h3><p>如果从<code>shared</code>的<code>popHead</code>中没拿到可服用的对象，需要通过<code>getSlow</code>来获取</p><pre><code>func (p *Pool) getSlow(pid int) interface{} {
    size := atomic.LoadUintptr(&amp;p.localSize) // load-acquire
    locals := p.local                        // load-consume
    // 遍历locals，从其他P上的尾部窃取
    for i := 0; i &lt; int(size); i++ {
        l := indexLocal(locals, (pid+i+1)%int(size))
        if x, _ := l.shared.popTail(); x != nil {
            return x
        }
    }

    size = atomic.LoadUintptr(&amp;p.victimSize)
    if uintptr(pid) &gt;= size {
        return nil
    }
    // 尝试从victim指向的poolLocal中，按照先private -&gt; shared的顺序获取
    locals = p.victim
    l := indexLocal(locals, pid)
    if x := l.private; x != nil {
        l.private = nil
        return x
    }
    for i := 0; i &lt; int(size); i++ {
        l := indexLocal(locals, (pid+i)%int(size))
        if x, _ := l.shared.popTail(); x != nil {
            return x
        }
    }

    atomic.StoreUintptr(&amp;p.victimSize, 0)

    return nil
}
</code></pre><p>通过遍历locals获取对象，使用到<code>victim</code>字段指向的<code>[]poolLocal</code>。这里其实引用了一种叫做<code>Victim Cache</code>的机制，具体解释详见<a href="https://en.wikipedia.org/wiki/Victim_cache" target="_blank" rel="noopener">这里</a>。</p><h4 id="poolChain-popTail"><a href="#poolChain-popTail" class="headerlink" title="poolChain.popTail"></a>poolChain.popTail</h4><pre><code>func (c *poolChain) popTail() (interface{}, bool) {
    d := loadPoolChainElt(&amp;c.tail)
    if d == nil {
        return nil, false
    }

    for {
        d2 := loadPoolChainElt(&amp;d.next)

        if val, ok := d.popTail(); ok {
            return val, ok
        }

        if d2 == nil {
            return nil, false
        }
        if atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) {
            storePoolChainElt(&amp;d2.prev, nil)
        }
        d = d2
    }
}
</code></pre><ul><li><code>d2</code>是<code>d</code>的<code>next</code>节点，<code>d</code>已经为链表尾部了，这里也应证了我们刚才说到的<code>poolChain</code>链表的首尾方向和正常的链表是相反的（至于为啥要这么设计，我也是比较懵逼）。如果<code>d2</code>为空证明已经到了链表的头部，所以直接返回；</li><li>从尾部节点get成功时直接返回，已经返回的这个位置，等待着下次get遍历时再删除。由于是从其他的P上窃取，可能发生同时多个协程获取对象，需要保证并发安全；</li><li>为什么<code>popHead</code>不去删除链表节点，两个原因吧。第一个，popHead只有当前协程在自己的P上操作，popTail是窃取，如果在<code>popHead</code>中操作，也需要原子操作，作者应该是希望把get阶段的开销降到最低；第二个，因为<code>poolChain</code>结构本身是链表，无论在哪一步做结果都是一样，不如统一放在尾部获取时删除。</li></ul><h4 id="poolDequeue-popTail"><a href="#poolDequeue-popTail" class="headerlink" title="poolDequeue.popTail"></a>poolDequeue.popTail</h4><pre><code>func (d *poolDequeue) popTail() (interface{}, bool) {
    var slot *eface
    for {
        ptrs := atomic.LoadUint64(&amp;d.headTail)
        head, tail := d.unpack(ptrs)
        if tail == head {
            return nil, false
        }
        ptrs2 := d.pack(head, tail+1)
        if atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) {
            slot = &amp;d.vals[tail&amp;uint32(len(d.vals)-1)]
            break
        }
    }

    val := *(*interface{})(unsafe.Pointer(slot))
    if val == dequeueNil(nil) {
        val = nil
    }
    slot.val = nil
    atomic.StorePointer(&amp;slot.typ, nil)

    return val, true
}
</code></pre><p>和<code>poolDequeue.popHead</code>方法逻辑基本差不多，由于<code>popTail</code>存在多个协程同时遍历，需要通过CAS获取，最后设置<code>slot</code>为空。</p><h3 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h3><pre><code>func (p *Pool) Put(x interface{}) {
    if x == nil {
        return
    }
    if race.Enabled {
        if fastrand()%4 == 0 {
            // Randomly drop x on floor.
            return
        }
        race.ReleaseMerge(poolRaceAddr(x))
        race.Disable()
    }
    l, _ := p.pin()
    if l.private == nil {
        l.private = x
        x = nil
    }
    if x != nil {
        l.shared.pushHead(x)
    }
    runtime_procUnpin()
    if race.Enabled {
        race.Enable()
    }
}
</code></pre><p><code>put</code>方法相关逻辑和<code>get</code>很像，先设置<code>poolLocal</code>的<code>private</code>，如果<code>private</code>已有，通过<code>shared.pushHead</code>写入。</p><h4 id="poolChain-pushHead"><a href="#poolChain-pushHead" class="headerlink" title="poolChain.pushHead"></a>poolChain.pushHead</h4><pre><code>func (c *poolChain) pushHead(val interface{}) {
    d := c.head
    if d == nil {
        // 初始化环，数量为2的幂
        const initSize = 8
        d = new(poolChainElt)
        d.vals = make([]eface, initSize)
        c.head = d
        storePoolChainElt(&amp;c.tail, d)
    }

    if d.pushHead(val) {
        return
    }

    // 如果环已满，按照2倍大小创建新的ring。注意这里有最大数量限制
    newSize := len(d.vals) * 2
    if newSize &gt;= dequeueLimit {
        // Can&#39;t make it any bigger.
        newSize = dequeueLimit
    }

    d2 := &amp;poolChainElt{prev: d}
    d2.vals = make([]eface, newSize)
    c.head = d2
    storePoolChainElt(&amp;d.next, d2)
    d2.pushHead(val)
}
</code></pre><p>如果节点是空，则创建一个新的poolChainElt对象作为头节点,然后调用pushHead放入到环状队列中.如果放置失败，那么创建一个2倍大小且不超过dequeueLimit（2的30次方）的poolChainElt节点。所有的vals长度必须为2的整数幂。</p><pre><code>func (d *poolDequeue) pushHead(val interface{}) bool {
    ptrs := atomic.LoadUint64(&amp;d.headTail)
    head, tail := d.unpack(ptrs)
    if (tail+uint32(len(d.vals)))&amp;(1&lt;&lt;dequeueBits-1) == head {
        return false
    }
    slot := &amp;d.vals[head&amp;uint32(len(d.vals)-1)]

    typ := atomic.LoadPointer(&amp;slot.typ)
    if typ != nil {
        return false
    }

    if val == nil {
        val = dequeueNil(nil)
    }
    *(*interface{})(unsafe.Pointer(slot)) = val
    atomic.AddUint64(&amp;d.headTail, 1&lt;&lt;dequeueBits)
    return true
}
</code></pre><p>首先判断ring是否大小已满，然后找到head位置对应的slot判断typ是否为空，因为<code>popTail</code>是先设置 val，再将 typ 设置为 nil，有冲突会直接返回。</p><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>整个对象池通过几个主要的结构体构成，它们之间关系如下：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9b9fc326d584593a9ed18d8da06f158~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h4 id="poolCleanup"><a href="#poolCleanup" class="headerlink" title="poolCleanup"></a>poolCleanup</h4><p>注册了全局清理的func，在每次gc开始时运行。既然每次gc都会清理pool内对象，那么对象复用的优势在哪里呢？<br><code>poolCleanup</code>在每次gc时，会将<code>allPools</code>里的对象写入<code>oldPools</code>对象后再清除自身对象。那么就是说，如果申请的对象，会经过两次<code>gc</code>后，才会被彻底回收。<code>p.local</code>会先设置为<code>p.victim</code>，是不是有点类似新生代、老生代的感觉。</p><pre><code>func init() {
    runtime_registerPoolCleanup(poolCleanup)
}
func poolCleanup() {
    for _, p := range oldPools {
        p.victim = nil
        p.victimSize = 0
    }

    // Move primary cache to victim cache.
    for _, p := range allPools {
        p.victim = p.local
        p.victimSize = p.localSize
        p.local = nil
        p.localSize = 0
    }

    oldPools, allPools = allPools, nil
}
</code></pre><p>可以看出，在gc发生不频繁的场景，<code>sync.Pool</code>对象复用就可以减少内存的频繁申请和回收。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&amp;mid=2247487149&amp;idx=1&amp;sn=f38f2d72fd7112e19e97d5a2cd304430&amp;source=41#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&amp;mid=2247487149&amp;idx=1&amp;sn=f38f2d72fd7112e19e97d5a2cd304430&amp;source=41#wechat_redirect</a></li><li><a href="https://medium.com/@genchilu/whats-false-sharing-and-how-to-solve-it-using-golang-as-example-ef978a305e10" target="_blank" rel="noopener">https://medium.com/@genchilu/whats-false-sharing-and-how-to-solve-it-using-golang-as-example-ef978a305e10</a></li></ul></div><section class="comments" id="comments"><div id="gitment_thread"></div><link rel="stylesheet" href="//unpkg.com/gitment/style/default.css"><script src="//unpkg.com/gitment/dist/gitment.browser.js"></script><script>var gitment=new Gitment({id:"{{ page.date }}",owner:"8090Lambert",repo:"8090Lambert.github.io",oauth:{client_id:"b2e729afbaa762a4cecc",client_secret:"cb9b28cda56154edecbcf76d2ea66e5a0e12c209"}});gitment.render("comments")</script></section></div></div></div></article><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><p class="copyright text-muted"> &copy; 2016 - 2021<span class="with-love"><i class="fa fa-heart"></i></span> <span class="author">8090Lambert</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></p><p class="visit-statistics"> <span id="busuanzi_container_site_pv">本站总访问：<span id="busuanzi_value_site_pv"></span>次 &nbsp;&nbsp;&nbsp;&nbsp;</span></p><p></p></div></div></div></footer><script src="/js/highlight.pack.js"></script><script>document.addEventListener("DOMContentLoaded",function(e){Array.prototype.slice.call(document.getElementsByTagName("pre")).forEach(function(e,t){hljs.highlightBlock(e)})})</script></body></html>