<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="author" content="8090Lambert"><meta name="google-site-verification" content="NlVkPYQIz-6FEWSYj-zlvN-gVromFNmq2v7hUK_WyyM"><meta name="sogou_site_verification" content="GFRFxFpBEM"><meta property="og:title" content="Kafka四问"><meta property="og:description" content="A Programmer With Coding."><meta property="og:site_name" content="8090Lambert | Blog"><meta property="og:type" content="article"><meta property="og:image" content="http://8090lambert.cn"><link rel="alternate" href="/atom.xml" title="8090Lambert | Blog" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><title>8090Lambert | Blog</title><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-146263529-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script>var _hmt=_hmt||[]</script><script async src="//hm.baidu.com/hm.js?dfc9714182f4393d85cb19cc7ad9c231"></script></head><body><nav class="navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="collapse navbar-collapse site-menu"><ul class="nav navbar-nav navbar-right"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/about">About</a></li><li> <a href="mailto:<juzs215@gmail.com>">Email</a></li><li><a href="https://github.com/8090Lambert"><i class="icon fa fa-github fa-lg"></i></a></li></ul></div></div></nav><header class="site-header header-background intro-header" style="background-image:url(/img/banner.jpg)"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="page-title with-background-image"><p class="title">Kafka四问</p><p class="subtitle"></p></div></div></div></div></header><article><div class="container typo"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-info text-muted"> <span class="author info">By 8090Lambert</span> <span class="date-time info">On <span class="date">2019-12-27T22:35:09+08:00</span></span></div><div class="post-tags text-muted"> Tags: <a class="tag" href="/tags/kafka/">#kafka</a></div><div class="post-content"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="HW（HighWater）"><a href="#HW（HighWater）" class="headerlink" title="HW（HighWater）"></a>HW（HighWater）</h3><p>高水位，表示已经提交（commit）的最大日志偏移量（offset）,已提交是指 ISRs 中所有节点都已同步到这条日志</p><h3 id="LEO（Log-endOffset）"><a href="#LEO（Log-endOffset）" class="headerlink" title="LEO（Log endOffset）"></a>LEO（Log endOffset）</h3><p>日志最后偏移量，表示日志中下一条待写入消息的Offset</p><h3 id="ISRs"><a href="#ISRs" class="headerlink" title="ISRs"></a>ISRs</h3><p>每个 partition 有一个 leader 和多个 follower（副本因子&gt;1）,其中日志状态保持和 leader 同步的 follower 集合被称为 ISRs，于其对应的有落后于 leader 日志状态的副本集合称为 OSRs，ISRs + OSRs = AR（All Replication）</p><hr><h2 id="一、为什么不使用Quorum策略？"><a href="#一、为什么不使用Quorum策略？" class="headerlink" title="一、为什么不使用Quorum策略？"></a>一、为什么不使用Quorum策略？</h2><h3 id="Quorum-机制"><a href="#Quorum-机制" class="headerlink" title="Quorum 机制"></a>Quorum 机制</h3><p>Quorum 机制对集群节点数量有要求，如果需要容忍N个节点故障，集群整体需要2N+1个节点；Quorum 主要能应对集群出现 脑裂问题</p><h3 id="ISRs-机制"><a href="#ISRs-机制" class="headerlink" title="ISRs 机制"></a>ISRs 机制</h3><p>ISR 机制，如果要容忍N个节点故障，只需保证 ISR 中存在N+1个节点；ISR通过zookeeper来避免来保证leader的唯一</p><h2 id="二、数据一致性如何保证？"><a href="#二、数据一致性如何保证？" class="headerlink" title="二、数据一致性如何保证？"></a>二、数据一致性如何保证？</h2><ol><li>关闭unclean，保证新的Leader副本，是从ISRs集合中进行选举</li><li>设置ISRs的最小副本数 &gt;= 2（ISR中包括Leader副本）</li></ol><p>以下两类特殊的数据一致性问题，通过引入Leader Epoch机制解决（类似Raft的Terms）</p><h3 id="日志丢失问题"><a href="#日志丢失问题" class="headerlink" title="日志丢失问题"></a>日志丢失问题</h3><p><img src="http://8090lambert.cn/images/blog/kafka/log_miss.jpg" alt="log_miss"></p><ol><li>某一个时刻，Leader A收到 producer 的消息m2，并成功写入本地Page Cache中。Follower B拉取到m2，写入Page Cache但未刷盘。同步给Leader A HW=2，Leader A更新自身HW=2。此时，A、B同时崩溃</li><li>B先恢复，并成为leader 节点，A 恢复后成为follower，HW=2所以不需要截断自身的日志。</li><li>Leader B 收到了 producer 的m3消息，此时offset=1的日志，两个节点出现了不一致现象。（A=m2, B=m3）</li></ol><h3 id="引入Leader-Epoch解决"><a href="#引入Leader-Epoch解决" class="headerlink" title="引入Leader Epoch解决"></a>引入Leader Epoch解决</h3><p>两个问题产生的原因，都是follower节点在异常情况恢复后，通过自身的HW来决定日志的状态。其实，上面分析的场景和raft中的日志恢复类似，raft中的follower是和leader的日志不一致时，会以leader的日志为准进行日志恢复。而raft中的日志恢复很重要的一点是follower根据leader任期号进行日志比对，快速进行日志恢复，follower需要判断新旧leader的日志（可能由于分区等问题，短暂出现2个leader的情况），以最新leader的数据为准。<br>这里的leader epoch和raft中的 term 类似，用一个严格单调递增的id来标志。follower每次奔溃重启后，都需要去leader那边确认下当前leader的日志是从哪个offset开始的。</p><p>介绍这几个概念各自的用处：</p><ul><li>Leader Epoch：Leader纪元，单调递增的int值。</li><li>Leader Epoch Start Offset：Leader的第一个日志偏移，也标志了旧Leader最后一条日志的偏移</li><li>Leader Epoch Request：Follower向Leader发送请求时，Leader会判断当前纪元是否是自身的epoch，如果是则返回自己的LEO，否则返回下一个纪元的Leader Epoch Start Offset，follower通过这个值做日志的截断处理<blockquote><p>日志截断仅会发生在 follower 节点上</p></blockquote></li></ul><h2 id="三、如何保证高性能？"><a href="#三、如何保证高性能？" class="headerlink" title="三、如何保证高性能？"></a>三、如何保证高性能？</h2><ul><li>多副本：多副本机制，带来多节点的并发能力。由于内部的优先副本分配策略，可以尽可能的保证做到Leader副本的负载均衡（Leader副本被均匀的分配在不同的broker节点）。</li><li>磁盘的顺序读写：由于topic的每个partition的消息是不可变的，新消息写入时，不断追加到partition日志的末尾。因此，可以利用磁盘顺序写的特点。数据的删除，因为每个log 被划分为多个segment，每个segment对应一个物理文件，通过删除文件的方式清理partition内的数据。</li><li>利用Page Cache：引入Page Cache，由OS来决定刷盘的时机。Page Cache的使用，可以将多个非连续、小块写操作合并，提高磁盘的写入效率，同时减少对文件系统的频繁调用。Kafka本身是Java语言栈，如果使用堆内存做Cache，在kafka进程重启时，数据会丢失，而且堆内内存的占用比数据本身占用的内存大（因为有结构、辅助字段等必要信息存储）。</li><li>零拷贝技术：生产者写入数据时，通过mmap提升写数据消息日志落盘的性能；消费者读取消息时。</li><li>批量处理：在很多情况下，系统的瓶颈不是CPU或磁盘，而是网络IO传输。kafka的producer在收到消息时，在积累足够多的消息或等待足够长的时间后，再发送到broker，批处理分摊了网络传输开销，提升带宽利用率，类似 TCP 的 Nagle 算法。</li><li>数据压缩：合并消息，减少数据体积</li></ul><h2 id="四、如何保证消息的幂等性和顺序性？"><a href="#四、如何保证消息的幂等性和顺序性？" class="headerlink" title="四、如何保证消息的幂等性和顺序性？"></a>四、如何保证消息的幂等性和顺序性？</h2><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>一般消息系统需要具备三种常见的语义，at most once(至多一次)，at least once(至少一次)，exactly once(恰好一次)，大多数系统都可以做到at most once 和 at least once。</p><ol><li>PID (producer ID)，用来表示每个 producer 的唯一性（在开启幂等时，每次发送给 broker 时消息中都携带）</li><li>sequence numbers，producer 发送给 broker 的每条消息都会带响应的 sequence number，逐次递增<br><strong>在配置 enable.idempotence = true 时(开启幂等配置)，通过 pid + sequence number，保证了同一个 producer 在 topic-partition 维度的幂等性</strong></li></ol><h3 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h3><p>kafka producer 采用异步发送机制。KafkaProducer.send(ProducerRecord) 方法仅仅是把这条消息放入一个缓存中(即RecordAccumulator，本质上使用了队列来缓存记录)，同时后台的IO线程会不断扫描该缓存区，将满足条件的消息封装到某个 batch 中然后发送出去。在这个过程中有一个数据丢失的窗口：若IO线程发送之前 producer 挂掉了，累积在 Accumulator 中的数据的确有可能会丢失。而且当设置 max.in.flight.requests.per.connection &gt; 1 并且 retries &gt;= 1 时，发送到同一个 topic-partition 中的消息中，可能由于网络等其他问题，导致实际顺序与写入顺序不一致，max.in.flight.requests.per.connection = 1 保证有序。<br><strong>在开启了幂等的情况下，可以保证写入的顺序性</strong></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><h4 id="未设置幂等时"><a href="#未设置幂等时" class="headerlink" title="未设置幂等时"></a>未设置幂等时</h4><p><img src="http://8090lambert.cn/images/blog/kafka/unidempotence.jpg" alt="unidempotence"></p><h4 id="设置幂等时"><a href="#设置幂等时" class="headerlink" title="设置幂等时"></a>设置幂等时</h4><p><img src="http://8090lambert.cn/images/blog/kafka/idempotence.jpg" alt="idempotence"></p></div><section class="comments" id="comments"><div id="gitment_thread"></div><link rel="stylesheet" href="//unpkg.com/gitment/style/default.css"><script src="//unpkg.com/gitment/dist/gitment.browser.js"></script><script>var gitment=new Gitment({id:"{{ page.date }}",owner:"8090Lambert",repo:"8090Lambert.github.io",oauth:{client_id:"b2e729afbaa762a4cecc",client_secret:"cb9b28cda56154edecbcf76d2ea66e5a0e12c209"}});gitment.render("comments")</script></section></div></div></div></article><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><p class="copyright text-muted"> &copy; 2016 - 2021<span class="with-love"><i class="fa fa-heart"></i></span> <span class="author">8090Lambert</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></p><p class="visit-statistics"> <span id="busuanzi_container_site_pv">本站总访问：<span id="busuanzi_value_site_pv"></span>次 &nbsp;&nbsp;&nbsp;&nbsp;</span></p><p></p></div></div></div></footer><script src="/js/highlight.pack.js"></script><script>document.addEventListener("DOMContentLoaded",function(e){Array.prototype.slice.call(document.getElementsByTagName("pre")).forEach(function(e,t){hljs.highlightBlock(e)})})</script></body></html>