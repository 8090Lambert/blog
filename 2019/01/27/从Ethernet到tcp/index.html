<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="author" content="8090Lambert"><meta name="google-site-verification" content="NlVkPYQIz-6FEWSYj-zlvN-gVromFNmq2v7hUK_WyyM"><meta name="sogou_site_verification" content="GFRFxFpBEM"><meta property="og:title" content="从 Ethernet 到 tcp 包分析"><meta property="og:description" content="A Programmer With Coding."><meta property="og:site_name" content="8090Lambert | Blog"><meta property="og:type" content="article"><meta property="og:image" content="http://8090lambert.cn"><link rel="alternate" href="/atom.xml" title="8090Lambert | Blog" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><title>8090Lambert | Blog</title><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-146263529-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script>var _hmt=_hmt||[]</script><script async src="//hm.baidu.com/hm.js?dfc9714182f4393d85cb19cc7ad9c231"></script></head><body><nav class="navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="collapse navbar-collapse site-menu"><ul class="nav navbar-nav navbar-right"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/about">About</a></li><li> <a href="mailto:<juzs215@gmail.com>">Email</a></li><li><a href="https://github.com/8090Lambert"><i class="icon fa fa-github fa-lg"></i></a></li></ul></div></div></nav><header class="site-header header-background intro-header" style="background-image:url(/img/banner.jpg)"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="page-title with-background-image"><p class="title">从 Ethernet 到 tcp 包分析</p><p class="subtitle"></p></div></div></div></div></header><article><div class="container typo"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-info text-muted"> <span class="author info">By 8090Lambert</span> <span class="date-time info">On <span class="date">2019-01-27T21:28:41+08:00</span></span></div><div class="post-tags text-muted"> Tags: <a class="tag" href="/tags/http/">#http</a></div><div class="post-content"><h2 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h2><blockquote><p>“ 以太网是一种计算机局域网技术。IEEE组织的IEEE 802.3标准制定了以太网的技术标准，它规定了包括物理层的连线、电子信号和介质访问层协议的内容。以太网是目前应用最普遍的局域网技术，取代了其他局域网技术如令牌环、FDDI和ARCNET。” – Wiki百科</p></blockquote><p>从 Xerox 公布的 Ethernet I 发展到现在，有过6种以太帧格式：</p><ul><li>Ethernet I</li><li>Ethernet II</li><li>Ethernet 802.3 raw</li><li>Ethernet 802.3 SAP</li><li>802.3/802.2 LLC</li><li>802.3/802.2 SNAP</li></ul><p>其中主流应用的是 Ethernet II、802.3/802.2 LLC、802.3/802.2 SNAP 这三种，最常用的是 RFC894 定义，也就是 Ethernet II 的帧格式。</p><h3 id="Ethernet-II"><a href="#Ethernet-II" class="headerlink" title="Ethernet II"></a>Ethernet II</h3><p><img src="https://raw.githubusercontent.com/8090Lambert/material/master/20191031161211.png" alt=""></p><ul><li>目标 MAC 地址：6个字节（48位），发送时会先检查目标 MAC 的地址，与当前适配器的物理地址是否一致，不一致就丢弃；</li><li>源 MAC 地址：6个字段（48位），发送帧的网络适配器物理地址</li><li>类型：上层协议的类型，常见的有，0x0800 表示是 IPV4 协议，0x0806 表示是 ARP 协议，0x86DD 表示是 IPV6 协议，更多<a href="https://en.wikipedia.org/wiki/EtherType#Examples" target="_blank" rel="noopener">详见</a></li><li>数据报文：最小 46 字节，最大 1500 字节（MTU）</li></ul><h3 id="802-3-802-2-LLC"><a href="#802-3-802-2-LLC" class="headerlink" title="802.3/802.2 LLC"></a>802.3/802.2 LLC</h3><p><img src="https://raw.githubusercontent.com/8090Lambert/material/master/20191031163803.png" alt=""></p><ul><li>DASP：1个字节，目的服务访问点</li><li>SSAP：1个字节，源服务访问点<br>将 Ethernet II 帧头的<code>类型</code>字段替换为帧<code>长度</code>，并且因为新增加了 DASP, SSAP，Control这三个各占1字节的字段，报文的长度也调整为：43~1497，它们三个字段作为 LLC 的头</li></ul><h3 id="802-3-802-2-SNAP"><a href="#802-3-802-2-SNAP" class="headerlink" title="802.3/802.2 SNAP"></a>802.3/802.2 SNAP</h3><p><img src="https://raw.githubusercontent.com/8090Lambert/material/master/20191031165124.png" alt=""></p><ul><li>类型：2个字节，不同于 Ethernet II 的类型字段</li><li>OUI ID：3个字节，通常都为 0<br>数据报文变为：38~1492字节</li></ul><p>Ethernet 帧，从最上层（应用层）发送的数据单元（PDU），每经过一层，都会把上层整个的 PDU 作为下层 PDU 的 data 域，然后加上<br>自己的协议头；接受端，同下而上的层层拆掉每层的头部。了解了这些，我们尝试抓包具体分析每个字段</p><h2 id="Tcp-报文"><a href="#Tcp-报文" class="headerlink" title="Tcp 报文"></a>Tcp 报文</h2><p><code>$ tcpdump -i eth1 port 9527 -s 0 -w ./target9527.cap</code><br>用 <code>wireshark</code> 打开抓到的二进制报文，如图所示：<br><img src="https://raw.githubusercontent.com/8090Lambert/material/master/20191031172528.png" alt=""></p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>Frame 1，表示第1帧，源ip和目的ip分别是：172.24.31.67 和 10.96.77.128，都是内网ip。<br><img src="https://raw.githubusercontent.com/8090Lambert/material/master/20191031180719.png" alt=""></p><ul><li>type：0x0800 表示 IPV4</li><li>源 MAC 地址：04:25:c5:83:f5:64</li><li>目标设备mac地址：5e:38:57:10:84:d9</li><li>Flags：0x4000，没有拆包，如果请求报文大于 MTU，会拆多次发送</li><li>Times to live：ttl，存活时间，数据包每经过一个三层路由器设备时，ttl域的值减1，当其存活次数为0时，便会取消数据包的转发。ttl，默认值是64，如下图，经过 14 次到达目标ip，所有64-13=51<br><img src="https://raw.githubusercontent.com/8090Lambert/material/master/20191031182456.png" alt=""></li><li>SYN：1，表示 请求及建立连接，包括剩下的两次握手请求包<br><img src="https://raw.githubusercontent.com/8090Lambert/material/master/20191031193822.png" alt=""><br><img src="https://raw.githubusercontent.com/8090Lambert/material/master/20191031194009.png" alt=""></li></ul><h3 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h3><p><img src="https://raw.githubusercontent.com/8090Lambert/material/master/20191101175300.png" alt=""><br>从 Frame 4 至 Frame 7 是建立连接后，发送具体请求的数据包。首先，发送了 HTTP 协议的 GET 请求，收到请求后回复了ACK。具体看下：<br><img src="https://raw.githubusercontent.com/8090Lambert/material/master/20191101180306.png" alt=""></p><ul><li>在 GET 请求时，设置了标志位 ACK 和 <code>PSH</code>，<code>PSH</code> 是告诉接收端，立即交由应用层处理而不必等到<code>Recv socket buffer</code>写满</li><li>接收端回复 ACK 和 Seq number，接收端和发送端同样会再回复一个<code>PSH</code>标记的包，要求立即处理</li><li>最后，应用层通过 HTTP 协议回复报文，在回复报文时，<strong>这里要注意还有个标志位</strong>，在报文中，FIN=1，表示在返回的同时请求关闭连接<br><img src="https://raw.githubusercontent.com/8090Lambert/material/master/20191101181658.png" alt=""></li></ul><h3 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h3><p><img src="https://raw.githubusercontent.com/8090Lambert/material/master/20191101192901.png" alt=""><br>tcp 连接是双工的，所以任何建立连接的双方都可以发起关闭连接的请求。自己之前面试也总喜欢问这些问题，看看候选人到底理解的是否透彻，<br>可是大多数都不怎么清楚。言归正传，剩下的 Frame 8 至 Frame 11 是回复详情的 ACK 和 端开连接的 tcp 包。</p><ul><li>Frame 8 和 Frame 9，分别回复的是，Frame 6 <code>PSH</code>标志位的请求和 Frame 7 的 HTTP 请求</li><li>Frame 10 是连接另一边发起了关闭连接的请求，标志位 FIN=1</li><li>Frame 11 是发起关闭请求方，回复上一个 FIN=1 的 ACK 请求包</li></ul><p>四次挥手全部结束。有同学可以会比较疑惑，不是应该是4次请求吗，这里只有三次。<strong>解释下这个问题：因为服务端在响应HTTP请求时，因为知道自己已经发送完全部数据，所以在响应包里加上了四次挥手中的第一次 FIN=1 的请求</strong>。</p></div><section class="comments" id="comments"><div id="gitment_thread"></div><link rel="stylesheet" href="//unpkg.com/gitment/style/default.css"><script src="//unpkg.com/gitment/dist/gitment.browser.js"></script><script>var gitment=new Gitment({id:"{{ page.date }}",owner:"8090Lambert",repo:"8090Lambert.github.io",oauth:{client_id:"b2e729afbaa762a4cecc",client_secret:"cb9b28cda56154edecbcf76d2ea66e5a0e12c209"}});gitment.render("comments")</script></section></div></div></div></article><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><p class="copyright text-muted"> &copy; 2016 - 2021<span class="with-love"><i class="fa fa-heart"></i></span> <span class="author">8090Lambert</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></p><p class="visit-statistics"> <span id="busuanzi_container_site_pv">本站总访问：<span id="busuanzi_value_site_pv"></span>次 &nbsp;&nbsp;&nbsp;&nbsp;</span></p><p></p></div></div></div></footer><script src="/js/highlight.pack.js"></script><script>document.addEventListener("DOMContentLoaded",function(e){Array.prototype.slice.call(document.getElementsByTagName("pre")).forEach(function(e,t){hljs.highlightBlock(e)})})</script></body></html>