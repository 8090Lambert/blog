<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="author" content="8090Lambert"><meta name="google-site-verification" content="NlVkPYQIz-6FEWSYj-zlvN-gVromFNmq2v7hUK_WyyM"><meta name="sogou_site_verification" content="GFRFxFpBEM"><meta property="og:title" content="Golang的interface探究"><meta property="og:description" content="A Programmer With Coding."><meta property="og:site_name" content="8090Lambert | Blog"><meta property="og:type" content="article"><meta property="og:image" content="http://8090lambert.cn"><link rel="alternate" href="/atom.xml" title="8090Lambert | Blog" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><title>8090Lambert | Blog</title><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-146263529-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script>var _hmt=_hmt||[]</script><script async src="//hm.baidu.com/hm.js?dfc9714182f4393d85cb19cc7ad9c231"></script></head><body><nav class="navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="collapse navbar-collapse site-menu"><ul class="nav navbar-nav navbar-right"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/about">About</a></li><li> <a href="mailto:<juzs215@gmail.com>">Email</a></li><li><a href="https://github.com/8090Lambert"><i class="icon fa fa-github fa-lg"></i></a></li></ul></div></div></nav><header class="site-header header-background intro-header" style="background-image:url(/img/banner.jpg)"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="page-title with-background-image"><p class="title">Golang的interface探究</p><p class="subtitle"></p></div></div></div></div></header><article><div class="container typo"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-info text-muted"> <span class="author info">By 8090Lambert</span> <span class="date-time info">On <span class="date">2019-10-11T18:15:49+08:00</span></span></div><div class="post-tags text-muted"> Tags: <a class="tag" href="/tags/go/">#go</a></div><div class="post-content"><p>golang被诟病最多的，没有泛型应该算一个。作为强类型语言来说，没有泛型很多时候在业务开发上会有些不适应，但是它有个<code>interface</code><br>类型，被很多人拿来当泛型玩，如果你了解它的原理也是没问题的。<br>但是你真的了解吗？</p><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p><code>golang</code> 中的<code>interface</code>，可以将任意类型的变量赋予它。常见的我们区分两种，一种就是<code>struct</code>类型的，因为<code>struct</code><br>可能会有<code>func</code>；另外一种，就是非结构体的普通类型（下面提到的普通类型，都是指代除<code>struct</code>外的类型）</p><h4 id="eface"><a href="#eface" class="headerlink" title="eface"></a>eface</h4><pre><code>  1 package main
  2
  3 import &quot;fmt&quot;
  4
  5 func main() {
  6     var x int
  7     var y interface{}
  8     x = 1
  9     y = x
 10     fmt.Println(y)
 11 }
</code></pre><p>当我们把<code>int</code>类型的变量赋值给<code>interface</code>类型时，会发生什么：</p><pre><code>TEXT main.main(SB) /home/xiaoju/gomodule/runtime/main.go
    main.go:5    0x4a23a0    64488b0c25f8ffffff    mov rcx, qword ptr fs:[0xfffffff8]
    main.go:5    0x4a23a9    488d4424f8        lea rax, ptr [rsp-0x8]
    main.go:5    0x4a23ae    483b4110        cmp rax, qword ptr [rcx+0x10]
    main.go:5    0x4a23b2    0f86c7000000        jbe 0x4a247f
=&gt;    main.go:5    0x4a23b8*    4881ec88000000        sub rsp, 0x88
    main.go:5    0x4a23bf    4889ac2480000000    mov qword ptr [rsp+0x80], rbp
    main.go:5    0x4a23c7    488dac2480000000    lea rbp, ptr [rsp+0x80]
    main.go:6    0x4a23cf    48c744243000000000    mov qword ptr [rsp+0x30], 0x0
    main.go:7    0x4a23d8    0f57c0            xorps xmm0, xmm0
    main.go:7    0x4a23db    0f11442448        movups xmmword ptr [rsp+0x48], xmm0
    main.go:8    0x4a23e0    48c744243001000000    mov qword ptr [rsp+0x30], 0x1
    main.go:9    0x4a23e9    48c7042401000000    mov qword ptr [rsp], 0x1
    main.go:9    0x4a23f1    e89a70f6ff        call $runtime.convT64
</code></pre><p>追到<code>runtime</code>的<code>convT64</code>方法，一探究竟。</p><pre><code>// type uint64InterfacePtr uint64
// var uint64Eface interface{} = uint64InterfacePtr(0)
// var uint64Type *_type = (*eface)(unsafe.Pointer(&amp;uint64Eface))._type

func convT64(val uint64) (x unsafe.Pointer) {
    if val == 0 {
        x = unsafe.Pointer(&amp;zeroVal[0])
    } else {
        x = mallocgc(8, uint64Type, false)
        *(*uint64)(x) = val
    }
    return
}
</code></pre><p>这个方法返回了 <code>val</code> 的指针，其中<code>uint64Type</code>就是一个 0 值的<code>uint64</code>指针。有个疑问，这里<code>uint64Type</code>定义时，<code>eface</code> 是什么：</p><pre><code>type eface struct {
    _type *_type
    data  unsafe.Pointer
}
</code></pre><p>这个结构体，恰好满足了，对于普通类型转换<code>interface</code>，或者说是将普通类型赋值给<code>interface</code>所必须的两个字段，当前类型的<code>type</code><br>和<code>值</code>（这里貌似有点绕口）。真实的是，<code>eface</code>确实就是表示这类<code>interface</code>的结构体，在<code>runtime</code>中，还能看到其他普通类型的转换，<br><code>convTslice</code>、<code>convTstring</code>、<code>convT64</code>、<code>convT32</code>等其他几个方法。</p><h4 id="iface"><a href="#iface" class="headerlink" title="iface"></a>iface</h4><p>如果是一个拥有<code>func</code>的<code>struct</code>类型的变量，赋值给另一个<code>interface</code>，这类的<code>interface</code>在底层是怎么存的呢。如下所示：</p><pre><code>  1 package main                                                                                                                                                                                                                
  2 
  3 import &quot;fmt&quot;
  4 
  5 type Human interface{ Introduce() string }
  6 
  7 type Bob struct{ Human }
  8 
  9 func (b Bob) Introduce() string { return &quot;Name: Bob&quot; }
 10 
 11 func main() {
 12     var y Human
 13     x := Bob{}
 14     y = x
 15     fmt.Println(y)
 16 }
</code></pre><pre><code>TEXT main.main(SB) /Users/such/gomodule/runtime/main.go
        main.go:11      0x10b71a0       65488b0c2530000000              mov rcx, qword ptr gs:[0x30]
        main.go:11      0x10b71a9       488d4424d0                      lea rax, ptr [rsp-0x30]
        main.go:11      0x10b71ae       483b4110                        cmp rax, qword ptr [rcx+0x10]
        main.go:11      0x10b71b2       0f860f010000                    jbe 0x10b72c7
        ...省略部分指令
        main.go:14      0x10b7202       e84921f5ff                      call $runtime.convT2I
</code></pre><p>看汇编代码，在 <code>16</code> 行时，调用了<code>runtime.convT2I</code>，这个方法返回的类型是<code>iface</code></p><pre><code>func convT2I(tab *itab, elem unsafe.Pointer) (i iface) {
    t := tab._type
    if raceenabled {
        raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2I))
    }
    if msanenabled {
        msanread(elem, t.size)
    }
    x := mallocgc(t.size, t, true)
    typedmemmove(t, x, elem)
    i.tab = tab
    i.data = x
    return
}
</code></pre><p><code>itab</code>包括具体值的<code>type</code>和 interface 的<code>type</code>，还有其他字段</p><pre><code>type itab struct {
    inter *interfacetype    // 接口定义的类型
    _type *_type            // 接口指向具体值的 type
    hash  uint32            // 类型的hash值
    _     [4]byte
    fun   [1]uintptr        // 判断接口是否实现所有方法（下面会讲到）
}
</code></pre><p>在<code>itab</code>结构体的<code>init</code>方法中，是所有字段的初始化，重点看这个方法：</p><pre><code>func (m *itab) init() string {
    inter := m.inter
    typ := m._type
    x := typ.uncommon()

    // 在 interfacetype 的结构体中，mhdr 存着所有需要实现的方法的
    // 结构体切片 []imethod，都是按照方法名的字典序排列的，其中：
    // ni 是全量的方法（所有要实现的方法）的个数
    // nt 是已实现的方法的个数
    ni := len(inter.mhdr)
    nt := int(x.mcount)
    xmhdr := (*[1 &lt;&lt; 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]
    j := 0
    methods := (*[1 &lt;&lt; 16]unsafe.Pointer)(unsafe.Pointer(&amp;m.fun[0]))[:ni:ni]
    var fun0 unsafe.Pointer
imethods:
    for k := 0; k &lt; ni; k++ {   // 从第一个开始，逐个对比
        i := &amp;inter.mhdr[k]
        itype := inter.typ.typeOff(i.ityp)
        name := inter.typ.nameOff(i.name)
        iname := name.name()
        ipkg := name.pkgPath()
        if ipkg == &quot;&quot; {
            ipkg = inter.pkgpath.name()
        }
        for ; j &lt; nt; j++ {
            t := &amp;xmhdr[j]
            tname := typ.nameOff(t.name)
            // 比较已实现方法的 type 和 name 是否一致
            if typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname {
                pkgPath := tname.pkgPath()
                if pkgPath == &quot;&quot; {
                    pkgPath = typ.nameOff(x.pkgpath).name()
                }
                if tname.isExported() || pkgPath == ipkg {
                    if m != nil {
                        // 计算每个 method 对应代码块的内存地址
                        ifn := typ.textOff(t.ifn)
                        if k == 0 {
                            fun0 = ifn // we&#39;ll set m.fun[0] at the end
                        } else {
                            methods[k] = ifn
                        }
                    }
                    continue imethods
                }
            }
        }
        // 如果没有找到，将 func[0] 设置为0，返回该实现的 method 的 name
        m.fun[0] = 0
        return iname
    }
    // 第一个方法的 ptr 和 type 的 hash
    m.fun[0] = uintptr(fun0)
    m.hash = typ.hash
    return &quot;&quot;
}
</code></pre><h4 id="itabTable"><a href="#itabTable" class="headerlink" title="itabTable"></a>itabTable</h4><p>还有一种将<code>interface</code>类型的实现，赋值给另外一个<code>interface</code>：</p><pre><code>TEXT main.main(SB) /Users/such/gomodule/runtime/main.go
    ...省略部分指令
    main.go:18    0x10b71f5    488d842480000000        lea rax, ptr [rsp+0x80]
    main.go:18    0x10b71fd    4889442408            mov qword ptr [rsp+0x8], rax
    main.go:18    0x10b7202    e84921f5ff            call $runtime.convT2I
</code></pre><pre><code>func convI2I(inter *interfacetype, i iface) (r iface) {
    tab := i.tab
    if tab == nil {
        return
    }
    if tab.inter == inter {
        r.tab = tab
        r.data = i.data
        return
    }
    r.tab = getitab(inter, tab._type, false)
    r.data = i.data
    return
}
</code></pre><p>通过前面的分析，我们又知道， <code>iface</code> 是由 <code>tab</code> 和 <code>data</code> 两个字段组成。所以，实际上 <code>convI2I</code> 函数真正要做的事，<br>找到新 <code>interface</code> 的 <code>tab</code> 和 <code>data</code>，就大功告成了。在<code>iface.go</code> 文件头部定义了<code>itabTable</code>全局哈希表存所有<code>itab</code>，<br>其实就是<code>空间换时间</code>的思想。<br><code>itabTable</code>是<code>itabTableType</code>结构体（我的golang版本是1.12.7）</p><pre><code>type itabTableType struct {
    size    uintptr             // 大小，2的幂
    count   uintptr             // 已有的 itab entry 个数
    entries [itabInitSize]*itab // 保存 itab entry
}
</code></pre><h5 id="getitab"><a href="#getitab" class="headerlink" title="getitab"></a>getitab</h5><p><code>getitab</code>是查找<code>itab</code>的方法</p><pre><code>func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
    if len(inter.mhdr) == 0 {
        throw(&quot;internal error - misuse of itab&quot;)
    }
    if typ.tflag&amp;tflagUncommon == 0 {
        if canfail {
            return nil
        }
        name := inter.typ.nameOff(inter.mhdr[0].name)
        panic(&amp;TypeAssertionError{nil, typ, &amp;inter.typ, name.name()})
    }

    var m *itab
    t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(&amp;itabTable)))
    if m = t.find(inter, typ); m != nil {
        goto finish
    }

    // Not found.  Grab the lock and try again.
    lock(&amp;itabLock)
    if m = itabTable.find(inter, typ); m != nil {
        unlock(&amp;itabLock)
        goto finish
    }

    // Entry doesn&#39;t exist yet. Make a new entry &amp; add it.
    m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &amp;memstats.other_sys))
    m.inter = inter
    m._type = typ
    m.init()
    itabAdd(m)
    unlock(&amp;itabLock)
finish:
    if m.fun[0] != 0 {
        return m
    }
    if canfail {
        return nil
    }
    // 如果不是 &quot;_, ok := &quot; 类型的断言，会有panic
    panic(&amp;TypeAssertionError{concrete: typ, asserted: &amp;inter.typ, missingMethod: m.init()})
}
</code></pre><p>会调用<code>find</code>方法，根据<code>interfacetype</code>和<code>_type</code>的 hash 值，在<code>itabTable</code>中查找，找到的话直接返回；<br>否则，生成新的<code>itab</code>，加入 <code>itabTable</code> 中。有个问题，就是为什么第一次不加锁找，而第二次加锁？<br>我个人的理解是：<code>首先：应该还是想避免锁的开销（之前在滴滴有幸听过曹大分享【内存重排】，对常用package在concurrently时，锁引起的问题做了一些分析。）， 而第二次加锁，我觉得更多的是在未找到 itab 后，会新生成一个 itab 写入全局哈希表中，如果有其他协程在查询时，也未找到，可以并发安全写入。</code></p><h5 id="itabAdd"><a href="#itabAdd" class="headerlink" title="itabAdd"></a>itabAdd</h5><pre><code>func itabAdd(m *itab) {
    if getg().m.mallocing != 0 {
        throw(&quot;malloc deadlock&quot;)
    }

    t := itabTable
    if t.count &gt;= 3*(t.size/4) { // 75% load factor
        t2 := (*itabTableType)(mallocgc((2+2*t.size)*sys.PtrSize, nil, true))
        t2.size = t.size * 2

        iterate_itabs(t2.add)
        if t2.count != t.count {
            throw(&quot;mismatched count during itab table copy&quot;)
        }
        atomicstorep(unsafe.Pointer(&amp;itabTable), unsafe.Pointer(t2))
        t = itabTable
    }
    t.add(m)
}
</code></pre><p><code>itabAdd</code> 是添加<code>itab</code>加入<code>itabTable</code>的方法。既然是<code>hash</code>表，就一定会发生<code>扩容</code>。每次都<br>是<code>2</code>的倍数的增长，创建新的 <code>itabTable</code> 再<code>原子</code>的替换。在 <code>iterate_itabs</code>（复制）时，并<br>未加锁，这里不是协程安全的，而是在添加前，在<code>getitab</code>方法中有锁的操作，会等待复制完成。</p></div><section class="comments" id="comments"><div id="gitment_thread"></div><link rel="stylesheet" href="//unpkg.com/gitment/style/default.css"><script src="//unpkg.com/gitment/dist/gitment.browser.js"></script><script>var gitment=new Gitment({id:"{{ page.date }}",owner:"8090Lambert",repo:"8090Lambert.github.io",oauth:{client_id:"b2e729afbaa762a4cecc",client_secret:"cb9b28cda56154edecbcf76d2ea66e5a0e12c209"}});gitment.render("comments")</script></section></div></div></div></article><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><p class="copyright text-muted"> &copy; 2016 - 2021<span class="with-love"><i class="fa fa-heart"></i></span> <span class="author">8090Lambert</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></p><p class="visit-statistics"> <span id="busuanzi_container_site_pv">本站总访问：<span id="busuanzi_value_site_pv"></span>次 &nbsp;&nbsp;&nbsp;&nbsp;</span></p><p></p></div></div></div></footer><script src="/js/highlight.pack.js"></script><script>document.addEventListener("DOMContentLoaded",function(e){Array.prototype.slice.call(document.getElementsByTagName("pre")).forEach(function(e,t){hljs.highlightBlock(e)})})</script></body></html>