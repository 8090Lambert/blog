<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="author" content="8090Lambert"><meta name="google-site-verification" content="NlVkPYQIz-6FEWSYj-zlvN-gVromFNmq2v7hUK_WyyM"><meta name="sogou_site_verification" content="GFRFxFpBEM"><meta property="og:title" content="Redis-字典"><meta property="og:description" content="A Programmer With Coding."><meta property="og:site_name" content="8090Lambert | Blog"><meta property="og:type" content="article"><meta property="og:image" content="http://8090lambert.cn"><link rel="alternate" href="/atom.xml" title="8090Lambert | Blog" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><title>8090Lambert | Blog</title><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-146263529-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script>var _hmt=_hmt||[]</script><script async src="//hm.baidu.com/hm.js?dfc9714182f4393d85cb19cc7ad9c231"></script></head><body><nav class="navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="collapse navbar-collapse site-menu"><ul class="nav navbar-nav navbar-right"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/about">About</a></li><li> <a href="mailto:<juzs215@gmail.com>">Email</a></li><li><a href="https://github.com/8090Lambert"><i class="icon fa fa-github fa-lg"></i></a></li></ul></div></div></nav><header class="site-header header-background intro-header" style="background-image:url(/img/banner.jpg)"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="page-title with-background-image"><p class="title">Redis-字典</p><p class="subtitle"></p></div></div></div></div></header><article><div class="container typo"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-info text-muted"> <span class="author info">By 8090Lambert</span> <span class="date-time info">On <span class="date">2018-11-29T22:51:47+08:00</span></span></div><div class="post-tags text-muted"> Tags: <a class="tag" href="/tags/redis/">#redis</a></div><div class="post-content"><p>Redis 还有一种比较常用的数据类型，字典。C 语言没有这种数据结构，但是 在JAVA 语言中的 <code>map</code>，和 PHP 语言里的 关联数组，就是这种类型，它用来保存 <code>key</code> =&gt; <code>value</code> 的键值对，要求键必须是唯一，在字段中，已知一个 <code>key</code>，对这个的 <code>key</code> 对应 <code>value</code> 做 CRUD操作，都非常方便。</p><p>Redis 自己实现了这个结构，并且用它来作 哈希键的底层实现之一，如果 <strong>一个哈希类型包含的键值对较多</strong> 或者 <strong>键值对中的元素都是较长的字符串</strong>，就会用 字典 来作为它的实现。数据库的 CRUD 操作也是作用在 字典上。具体的源码在文件 <code>src/dict.h</code>，它的底层使用哈希表，哈希表内部可以拥有多个节点，每个节点上就存储这一个键值对。</p><pre><code class="angular2html">// 哈希表
typedef struct dictht {
    dictEntry **table;  // 哈希表数组
    unsigned long size; // 哈希表大小，一般是2的指数
    unsigned long sizemask; // 哈希表掩码，等于 size - 1
    unsigned long used; // 哈希表已有节点数量，used / size 这个是装载因子，比值越大，hash冲突月 
} dictht;

// 哈希表节点
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
</code></pre><p>在 <code>dictht</code> 结构体中 <code>table</code> 数组中的每个元素，都是一个指向哈希表节点 <code>dictEntry</code> 的指针，<code>size</code> 标识dictEntry指针数组，就是 <code>table</code> 数组的长度，它总是2的指数；<code>sizemask</code> 的值为 <code>size - 1</code>， 这个属性和哈希值决定了一个键要被放在 <code>table</code> 数组的哪个索引位置上（通过hash &amp; sizemask计算出），<code>used</code> 的属性则记录了哈希表目前已有节点的数量，size / used 是装在因子，这个值越大，哈希冲突的概率就越高。</p><p>这个就是 <code>dict</code> 和 <code>dictEntry</code> 的结构示意：</p><p><img src="http://8090lambert.cn/images/blog/dict/dict_01.png" alt=""></p><p><code>dictEntry</code> 结构是哈希表的节点，其中 <code>key</code> 是键值对的键，而 <code>v</code> 是键值对的值，<code>v</code> 中可以是一个指针、uint64 的整数、uint64的整数或者是一个 double 的浮点数，<code>next</code> 属性是指向下一个哈希表节点 <code>dictEntry</code> 结构体的指针，所谓下一个哈希表节点，就是当哈希键 <code>key</code> 相同的哈希表节点，它们会挨个排列，前一个的 <code>next</code> 指针指向后一个。</p><h2 id="Hash键冲突"><a href="#Hash键冲突" class="headerlink" title="Hash键冲突"></a>Hash键冲突</h2><p>Redis 使用 MurmurHash 算法来计算键的hash值，虽然在效率上和随机性上很好，但是还是会产生 hash冲突。<br>针对这个问题，采用了 拉链法 解决冲突。<code>next</code> 指针，表示两个相同的hash组成的一个链表。<br>包含多个键hash值相同的情况：</p><p><img src="http://8090lambert.cn/images/blog/dict/dict_02.png" alt=""></p><p>每次冲突时，都会从头部插入新的键，时间复杂度保证都是O(1)。</p><p>在 <code>dict</code> 结构体里，管理这两个的 <code>dictht</code></p><pre><code class="angular2html">typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    unsigned long iterators; /* number of iterators currently running */
} dict;
</code></pre><p><code>type</code> 和 <code>privdata</code> 属性是为实现多态字典而设置的，主要是用于不同类型的键值对。其实，<code>type</code> 是指向 <code>dictType</code> 结构的指针，在 <code>dictType</code> 结构体中，保存着一系列的方法：</p><pre><code>typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);  // 计算哈希值
    void *(*keyDup)(void *privdata, const void *key);   // 复制键
    void *(*valDup)(void *privdata, const void *obj);   // 复制值
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);  // 对比键
    void (*keyDestructor)(void *privdata, void *key);   // 销毁键
    void (*valDestructor)(void *privdata, void *obj);   // 销毁值
} dictType;
</code></pre><p><code>ht</code> 是拥有两个元素的数组，每个都是一个 <code>dictht</code>。一般情况，使用第1个索引位置的哈希表来存储，第二个索引位置的哈希表一般是做 <code>rehash</code> 时使用的。<code>rehashidx</code> 就是表示是否正在做 <code>rehash</code>，如果目前不是正在进行，它的值为 -1。<code>iterators</code> 是当前正在运行的迭代器数目。</p><pre><code class="angular2html">typedef struct dictIterator {
    dict *d;
    long index;
    int table, safe;
    dictEntry *entry, *nextEntry;
    /* unsafe iterator fingerprint for misuse detection. */
    long long fingerprint;
} dictIterator; 
</code></pre><p>这是字典的迭代器。<code>d</code> 是指向字典的指针，<code>index</code> 是迭代器当前索引的位置。</p><h2 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h2><p>如果哈希表的数据变的越来越多，在装载因子（dictht 中 size / used 的比值）超过预定时，<br>这时，Redis 会对哈希表做 Rehash 操作，它采用的是一种增量式重哈希，就是将rehash的过程，<br>分散到所有对 dict 的增删改查操作中。<br>开始 rehash 后，所有的写入操作，都直接写入 ht[1] 里，同时，会将 ht[0] 哈希表在 rehashidx 上的所有键 rehash 至 ht[1]，<br>直到 ht[0] 中键的个数为 0时，rehash 结束。释放 ht[0], 再将 ht[1] 设为 ht[0], 重新申请一个空白哈希表作为新的 ht[1]。</p><p>##<br>Redis对于字典的操作就是这些，还有一些 API，没有做更深入的研究。</p></div><section class="comments" id="comments"><div id="gitment_thread"></div><link rel="stylesheet" href="//unpkg.com/gitment/style/default.css"><script src="//unpkg.com/gitment/dist/gitment.browser.js"></script><script>var gitment=new Gitment({id:"{{ page.date }}",owner:"8090Lambert",repo:"8090Lambert.github.io",oauth:{client_id:"b2e729afbaa762a4cecc",client_secret:"cb9b28cda56154edecbcf76d2ea66e5a0e12c209"}});gitment.render("comments")</script></section></div></div></div></article><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><p class="copyright text-muted"> &copy; 2016 - 2021<span class="with-love"><i class="fa fa-heart"></i></span> <span class="author">8090Lambert</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></p><p class="visit-statistics"> <span id="busuanzi_container_site_pv">本站总访问：<span id="busuanzi_value_site_pv"></span>次 &nbsp;&nbsp;&nbsp;&nbsp;</span></p><p></p></div></div></div></footer><script src="/js/highlight.pack.js"></script><script>document.addEventListener("DOMContentLoaded",function(e){Array.prototype.slice.call(document.getElementsByTagName("pre")).forEach(function(e,t){hljs.highlightBlock(e)})})</script></body></html>