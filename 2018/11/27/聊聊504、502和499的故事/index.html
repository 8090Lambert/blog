<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="author" content="8090Lambert"><meta name="google-site-verification" content="NlVkPYQIz-6FEWSYj-zlvN-gVromFNmq2v7hUK_WyyM"><meta name="sogou_site_verification" content="GFRFxFpBEM"><meta property="og:title" content="聊聊504、502和499的故事"><meta property="og:description" content="A Programmer With Coding."><meta property="og:site_name" content="8090Lambert | Blog"><meta property="og:type" content="article"><meta property="og:image" content="http://8090lambert.cn"><link rel="alternate" href="/atom.xml" title="8090Lambert | Blog" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><title>8090Lambert | Blog</title><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-146263529-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script>var _hmt=_hmt||[]</script><script async src="//hm.baidu.com/hm.js?dfc9714182f4393d85cb19cc7ad9c231"></script></head><body><nav class="navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="collapse navbar-collapse site-menu"><ul class="nav navbar-nav navbar-right"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/about">About</a></li><li> <a href="mailto:<juzs215@gmail.com>">Email</a></li><li><a href="https://github.com/8090Lambert"><i class="icon fa fa-github fa-lg"></i></a></li></ul></div></div></nav><header class="site-header header-background intro-header" style="background-image:url(/img/banner.jpg)"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="page-title with-background-image"><p class="title">聊聊504、502和499的故事</p><p class="subtitle"></p></div></div></div></div></header><article><div class="container typo"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-info text-muted"> <span class="author info">By 8090Lambert</span> <span class="date-time info">On <span class="date">2018-11-27T22:21:37+08:00</span></span></div><div class="post-tags text-muted"> Tags: <a class="tag" href="/tags/http/">#http</a></div><div class="post-content"><p>每次工作中碰到 5xx 的 http 状态码，都会比较头疼，又要排查了，每次都是从 nginx 的 <code>error_log</code> 追溯，<br>一直到 <code>php_error_log</code>，确定大概位置，翻代码…</p><p>恰巧碰到最近组内在学习 <code>nginx</code> 源码，打算深入研究一下，如果有可能让偶发事件成可控事件，那一定能明白<br>其中的原因，更快定位问题，对日后工作排查，应该会有帮助。</p><h3 id="Gateway-Time-out"><a href="#Gateway-Time-out" class="headerlink" title="Gateway Time-out"></a>Gateway Time-out</h3><blockquote><p>504错误是（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>服务器（不一定是 Web 服务器）正在作为一个网关或代理来完成客户（如您的浏览器或我们的 CheckUpDown 机器人）<br>访问所需网址的请求。 为了完成您的 HTTP 请求， 该服务器访问一个上游服务器， 但没得到及时的响应。</p></blockquote><p>这是维基百科上直译过来的一段话，网关超时，可以推测下，对于我们常见的服务模型来说，就是 <code>client</code> 请求到 <code>nginx</code>，<br><code>php-fpm</code> 未在 <code>nginx</code> 的最大执行时间内返回。试着构造一下：</p><ul><li>首先准备环境：</li><li><code>Ubuntu 18.04 LTS</code>；<code>nginx version: nginx/1.14.0 (Ubuntu)</code>; <code>PHP 7.2.14-1+ubuntu18.04.1+deb.sury.org+1 (cli)</code></li><li>修改 Nginx 中 <code>fastcgi_read_timeout</code> = 3，这个参数是说从 fastcgi 读取数据的最大时间，单位为秒<br><img src="http://8090lambert.cn/images/blog/http/http_01.png" alt="nginx.conf"></li><li>php 代码<br><img src="http://8090lambert.cn/images/blog/http/http_02.png" alt="index.php"><br>重启 nginx，直接在浏览器请求;<br><img src="http://8090lambert.cn/images/blog/http/http_03.png" alt=""></li></ul><p>和推测的完全吻合，通俗点说，<strong>就是 php 在 <code>nginx</code> 超时时间(设置的3s)内未返回，<code>nginx</code> 等不及，就会返回给客户端 504</strong>,<br>error_log 如下,<br><code>2018/11/28s 00:13:05 [error] 3540#3540: *3 upstream timed out (110: Connection timed out) while reading response header from upstream, client: 192.168.10.1, server: mine.test, request: &quot;GET / HTTP/1.1&quot;, upstream: &quot;fastcgi://unix:/var/run/php/php7.2-fpm.sock&quot;, host: &quot;mine.test&quot;</code></p><h3 id="Bad-Gateway"><a href="#Bad-Gateway" class="headerlink" title="Bad Gateway"></a>Bad Gateway</h3><blockquote><p>502状态码是服务器（不一定是Web服务器）作为网关或代理，以满足客户的要求来访问所请求的URL 。此服务器收到无效响应从上游服务器访问履行它的要求。</p></blockquote><p><code>无效响应</code> 可以理解是下游服务（php-fpm）不可用</p><p>还是刚才的环境，这次，停掉 <code>php-fpm</code> 进程 (因为我是多版本共存的，nginx配置的是php7.2的php-fpm，剩下的都是7.1php-fpm的worker进程)<br><img src="http://8090lambert.cn/images/blog/http/http_04.png" alt="关闭php-fpm服务"><br>现在，访问刚才的url<br><img src="http://8090lambert.cn/images/blog/http/http_05.png" alt=""></p><p> 我们再模拟一种情况：在 <code>php-fpm.conf</code> 中有个参数设置</p><pre><code class="angularjs">; The timeout for serving a single request after which the worker process will
; be killed. This option should be used when the &#39;max_execution_time&#39; ini option
; does not stop script execution for some reason. A value of &#39;0&#39; means &#39;off&#39;.
; Available units: s(econds)(default), m(inutes), h(ours), or d(ays)
; Default Value: 0

request_terminate_timeout = 15
</code></pre><p>每个 php-fpm 的 worker 进程如果执行时间超过，会被 kill 掉。就是 php-fpm 等待程序的最大时长，<br>修改为 <code>request_terminate_timeout = 3</code>，然后重启 php-fpm，刷新浏览器。<br>发现和刚才的情况一样，也是 nginx 返回给 clint 一个 502 的错误页面。</p><p>在 nginx 的 error_log 里会出现这样一条日志：<br><code>2018/11/28 00:20:43 [error] 3793#3793: *20 connect() to unix:/var/run/php/php7.2-fpm.sock failed (111: Connection refused) while connecting to upstream, client: 192.168.10.1, server: mine.test, request: &quot;GET / HTTP/1.1&quot;, upstream: &quot;fastcgi://unix:/var/run/php/php7.2-fpm.sock:&quot;, host: &quot;mine.test&quot;</code></p><p>同时，access_log 里也会增加一条日志：<br><code>192.168.10.1 - - [28/Nov/2018:00:20:43 +0800] &quot;GET / HTTP/1.1&quot; 504 594 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36&quot;</code></p><p>这两种情况，有个共同点：<strong>就是没有正常的返回给 nginx （不论是php-fpm服务不可用还是php-fpm等待超时，主动断开）。</strong></p><h3 id="Client-has-closed-connection"><a href="#Client-has-closed-connection" class="headerlink" title="Client has closed connection"></a>Client has closed connection</h3><p><code>499：客户端关闭连接</code> 这个乍一看，是客户端的锅，是它先“动手”，关闭连接的。从标准的 RFC2616 协议中，是没有 499 状态码，<br>是 nginx 自己定义的。</p><p>根据字面的意思，这种情况是客户端主动断开连接，或许是服务端在客户端最大等待时间内，没有返回结果，导致客户端等不及。<br>这次我们在终端试试（在写的时候，已用浏览器测试，奈何浏览器作为客户端，等待时间太长了，复现不了）。</p><p>服务端还是这行代码：</p><pre><code class="angularjs">&lt;?php

sleep(10);

echo &quot;hello world&quot;;
</code></pre><p>在终端执行，紧接着 <code>command + c</code> 强制终止进程</p><blockquote><p>$ curl <a href="http://mine.test" target="_blank" rel="noopener">http://mine.test</a></p></blockquote><p>从 nginx 的 access_log 中查看日志发现：<br><code>192.168.10.1 - - [28/Nov/2018:14:42:26 +0800] &quot;GET / HTTP/1.1&quot; 499 0 &quot;-&quot; &quot;curl/7.54.0&quot;</code></p><p>因为客户端主动断开，在下游的 nginx 就会有一条 499 的日志。在普通的 web 应用中很少见，但是<br>在微服务下，跨部门跨组之间的调用，都是 http 请求，如果下游的服务不够稳定，这种状态码一般很多。<br><strong>上游要保证，在连接等待的时候，必须有合理的超时时间，不能因为下游服务挂掉了，而拖垮自己，导致<br>整个服务雪崩。</strong></p><p>说到底，这三种状态码（不考虑php-fpm服务不可用时的502），都是 <code>nginx</code> 、<code>php-fpm</code> 和 <code>client</code> 中的<br>两者之间发生超时，只要能够分清是谁timeout，就能准确的判断会发生的情况。</p></div><section class="comments" id="comments"><div id="gitment_thread"></div><link rel="stylesheet" href="//unpkg.com/gitment/style/default.css"><script src="//unpkg.com/gitment/dist/gitment.browser.js"></script><script>var gitment=new Gitment({id:"{{ page.date }}",owner:"8090Lambert",repo:"8090Lambert.github.io",oauth:{client_id:"b2e729afbaa762a4cecc",client_secret:"cb9b28cda56154edecbcf76d2ea66e5a0e12c209"}});gitment.render("comments")</script></section></div></div></div></article><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><p class="copyright text-muted"> &copy; 2016 - 2021<span class="with-love"><i class="fa fa-heart"></i></span> <span class="author">8090Lambert</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></p><p class="visit-statistics"> <span id="busuanzi_container_site_pv">本站总访问：<span id="busuanzi_value_site_pv"></span>次 &nbsp;&nbsp;&nbsp;&nbsp;</span></p><p></p></div></div></div></footer><script src="/js/highlight.pack.js"></script><script>document.addEventListener("DOMContentLoaded",function(e){Array.prototype.slice.call(document.getElementsByTagName("pre")).forEach(function(e,t){hljs.highlightBlock(e)})})</script></body></html>