<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="author" content="8090Lambert"><meta name="google-site-verification" content="NlVkPYQIz-6FEWSYj-zlvN-gVromFNmq2v7hUK_WyyM"><meta name="sogou_site_verification" content="GFRFxFpBEM"><meta property="og:title" content="Redis-跳跃表"><meta property="og:description" content="A Programmer With Coding."><meta property="og:site_name" content="8090Lambert | Blog"><meta property="og:type" content="article"><meta property="og:image" content="http://8090lambert.cn"><link rel="alternate" href="/atom.xml" title="8090Lambert | Blog" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><title>8090Lambert | Blog</title><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-146263529-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script>var _hmt=_hmt||[]</script><script async src="//hm.baidu.com/hm.js?dfc9714182f4393d85cb19cc7ad9c231"></script></head><body><nav class="navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="collapse navbar-collapse site-menu"><ul class="nav navbar-nav navbar-right"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/about">About</a></li><li> <a href="mailto:<juzs215@gmail.com>">Email</a></li><li><a href="https://github.com/8090Lambert"><i class="icon fa fa-github fa-lg"></i></a></li></ul></div></div></nav><header class="site-header header-background intro-header" style="background-image:url(/img/banner.jpg)"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="page-title with-background-image"><p class="title">Redis-跳跃表</p><p class="subtitle"></p></div></div></div></div></header><article><div class="container typo"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-info text-muted"> <span class="author info">By 8090Lambert</span> <span class="date-time info">On <span class="date">2018-11-02T22:04:20+08:00</span></span></div><div class="post-tags text-muted"> Tags: <a class="tag" href="/tags/redis/">#redis</a></div><div class="post-content"><p>有一种查询效率特别高的有序的数据结构，跳跃表（SkipList），这种结构，在Redis和levelDB中，都有用到。<br>其实是在有序链表的基础上进行扩展，丰富了在链表中查找制定值，需要 O（N）的时间复杂度的问题，它在查<br>询时，能做到最快 O（1），平均 O（logN），最坏 O（N）的复杂度。</p><p>一般，要求查询效率高的结构，都会想到平衡树，但是树比跳跃表更复杂，但是效率，未必有跳跃表高。许多<br>时候可以用跳表来取代平衡树。</p><p>在 Redis 中，跳跃表作为 有序集合（ZSET）的底层实现之一和集群节点内部结构。源码在 <code>src/server.h</code> 中</p><pre><code class="angular2html">typedef struct zskiplist {
    struct zskiplistNode *header, *tail;    // 头节点指针和尾节点指针
    unsigned long length;   // 节点数量（不包括头节点）
    int level;  // 所有节点，层数最高的节点的层数
} zskiplist;
</code></pre><pre><code class="angular2html">/* ZSETs use a specialized version of Skiplists */
typedef struct zskiplistNode {
    sds ele;    // 数据值
    double score;   // 分值
    struct zskiplistNode *backward; // 后退指针
    struct zskiplistLevel { // 每个节点的层
        struct zskiplistNode *forward;  // 每层前进指针
        unsigned int span;  // 距离下个相同层的节点的跨度
    } level[];
} zskiplistNode;
</code></pre><p>作者 <code>antirez</code> 指出 Redis 跳跃表与一般跳跃表的不同</p><blockquote><p>a) this implementation allows for repeated scores. // 允许分值重复<br>b) the comparison is not just by key (our ‘score’) but by satellite data. // 对比的时候不仅比较分值还比较对象的值<br>c) there is a back pointer, so it’s a doubly linked list with the back pointers being only at “level 1”. // 有一个后退指针，即在第一层实现了一个双向链表，允许后退遍历</p></blockquote><p><img src="http://8090lambert.cn/images/blog/skiplist/skiplist_01.png" alt="跳跃表结构"><br>表头节点是一个拥有32个level的 <code>zskiplistNode</code> 结构，正向遍历跳表，就是从表头<br>的某层开始，一般层的数量越多，查询的效率就会越高，每次插入一个新跳表节点时，会随机<br>生成一个 1 ~ 32 的层数（对应表头节点，最高32层），从索引位置 0 ~ 31。</p><h3 id="跳跃表的查找"><a href="#跳跃表的查找" class="headerlink" title="跳跃表的查找"></a>跳跃表的查找</h3><p><img src="http://8090lambert.cn/images/blog/skiplist/skiplist_02.png" alt="跳跃表查找"><br>当我们要查找一个分值为46的节点时，普通的链表只能从头至尾循环查找，对于跳跃表，它每次<br>从 <code>level</code> 最高的层开始查找。</p><ol><li>首先，从 <code>zskiplist</code> 的头结点找到最高 <code>level</code> 的节点，55 <code>大于</code> 要找的46，根据层的 <code>backward</code> 指针后退至 L3 节点；</li><li>L3 节点的分值为 21 <code>小于</code> 46 ，则从 55 的下一层开始后退到 L2 节点；</li><li>L2 节点的分值 37 <code>小于</code> 46， 则从 L2 节点的下一层前进至 L1 节点；</li><li>L1 节点的分值为 46，查找成功</li></ol><p>少量的数据，在做这种对比的时候，优势并不明显，如果数据量特别多，跳过的元素数量<br>将会非常可观，效率的提升也会非常明显。</p><p>当跳跃表的多个元素分值（score）相同时，会按照成员对象的字典顺序进行排序，成员<br>对象小的节点排在靠近表头的位置，成员对象大的节点排在靠近表尾的位置。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>跳跃表是特别高效的节点查找方式，在工作中，在自己的程序设计时，如果有对已排序<br>的数据做查找时，它是比树更简单的一种思路。</p></div><section class="comments" id="comments"><div id="gitment_thread"></div><link rel="stylesheet" href="//unpkg.com/gitment/style/default.css"><script src="//unpkg.com/gitment/dist/gitment.browser.js"></script><script>var gitment=new Gitment({id:"{{ page.date }}",owner:"8090Lambert",repo:"8090Lambert.github.io",oauth:{client_id:"b2e729afbaa762a4cecc",client_secret:"cb9b28cda56154edecbcf76d2ea66e5a0e12c209"}});gitment.render("comments")</script></section></div></div></div></article><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><p class="copyright text-muted"> &copy; 2016 - 2021<span class="with-love"><i class="fa fa-heart"></i></span> <span class="author">8090Lambert</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></p><p class="visit-statistics"> <span id="busuanzi_container_site_pv">本站总访问：<span id="busuanzi_value_site_pv"></span>次 &nbsp;&nbsp;&nbsp;&nbsp;</span></p><p></p></div></div></div></footer><script src="/js/highlight.pack.js"></script><script>document.addEventListener("DOMContentLoaded",function(e){Array.prototype.slice.call(document.getElementsByTagName("pre")).forEach(function(e,t){hljs.highlightBlock(e)})})</script></body></html>