<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content=""><meta name="author" content="8090Lambert"><meta name="google-site-verification" content="NlVkPYQIz-6FEWSYj-zlvN-gVromFNmq2v7hUK_WyyM"><meta name="sogou_site_verification" content="GFRFxFpBEM"><meta property="og:title" content="对比IO和IO多路复用模型"><meta property="og:description" content="A Programmer With Coding."><meta property="og:site_name" content="8090Lambert | Blog"><meta property="og:type" content="article"><meta property="og:image" content="http://8090lambert.cn"><link rel="alternate" href="/atom.xml" title="8090Lambert | Blog" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><title>8090Lambert | Blog</title><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-146263529-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script>var _hmt=_hmt||[]</script><script async src="//hm.baidu.com/hm.js?dfc9714182f4393d85cb19cc7ad9c231"></script></head><body><nav class="navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="collapse navbar-collapse site-menu"><ul class="nav navbar-nav navbar-right"><li> <a href="/">Home</a></li><li> <a href="/archives">Archives</a></li><li> <a href="/about">About</a></li><li> <a href="mailto:<juzs215@gmail.com>">Email</a></li><li><a href="https://github.com/8090Lambert"><i class="icon fa fa-github fa-lg"></i></a></li></ul></div></div></nav><header class="site-header header-background intro-header" style="background-image:url(/img/banner.jpg)"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="page-title with-background-image"><p class="title">对比IO和IO多路复用模型</p><p class="subtitle"></p></div></div></div></div></header><article><div class="container typo"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-info text-muted"> <span class="author info">By 8090Lambert</span> <span class="date-time info">On <span class="date">2018-12-04T14:51:15+08:00</span></span></div><div class="post-tags text-muted"> Tags: <a class="tag" href="/tags/http/">#http</a></div><div class="post-content"><h2 id="IO-模式-和-IO-多路复用"><a href="#IO-模式-和-IO-多路复用" class="headerlink" title="IO 模式 和 IO 多路复用"></a>IO 模式 和 IO 多路复用</h2><h4 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h4><p>&emsp;&emsp;现在操作系统都采用虚拟寻址，<strong>处理器先产生一个虚拟地址，通过地址翻译成物理地址（内存的地址）</strong>，再通过总线的传递，最后处理器拿到某个物理地址返回的字节。</p><p>&emsp;&emsp;对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><p>&emsp;&emsp;<strong>补充：地址空间就是一个非负整数地址的有序集合。如{0,1,2…}。</strong></p><h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><p>&emsp;&emsp;为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（也叫调度）。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>&emsp;&emsp;从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ul><li>保存当前进程A的上下文<blockquote><p>上下文就是内核再次唤醒当前进程时所需要的状态，由一些对象（程序计数器、状态寄存器、用户栈等各种内核数据结构）的值组成。这些值包括描绘地址空间的页表、包含进程相关信息的进程表、文件表等。</p></blockquote></li><li>切换页全局目录以安装一个新的地址空间</li><li>恢复进程B的上下文</li><li>处理B进程逻辑</li><li>恢复进程A的上下文</li><li>…<blockquote><p>可以理解成一个比较耗资源的过程</p></blockquote></li></ul><h4 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h4><p>&emsp;&emsp;正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p><h4 id="文件描述符（FD）"><a href="#文件描述符（FD）" class="headerlink" title="文件描述符（FD）"></a>文件描述符（FD）</h4><p>&emsp;&emsp;文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。<br>&emsp;&emsp;文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。对于UNIX、Linux这样的操作系统的设计初衷就是：一切皆文件。</p><h4 id="直接I-O和缓存I-O"><a href="#直接I-O和缓存I-O" class="headerlink" title="直接I/O和缓存I/O"></a>直接I/O和缓存I/O</h4><p>&emsp;&emsp;缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，以write为例，数据会先被拷贝进程缓冲区，在拷贝到操作系统内核的缓冲区中，然后才会写到存储设备中。</p><p><strong>缓存I/O的write</strong><br><img src="https://8090lambert.cn/images/blog/io/01.png" alt="缓存I/O的write"></p><p><strong>直接I/O的write：（省去了拷贝到进程缓冲区这一步）</strong><br><img src="https://8090lambert.cn/images/blog/io/02.png" alt="直接I/O的write"></p><p><strong>write过程中会有很多次拷贝，知道数据全部写到磁盘。好了，准备知识概略复习了一下，开始探讨IO模式。</strong></p><h4 id="I-O模式"><a href="#I-O模式" class="headerlink" title="I/O模式"></a>I/O模式</h4><p>&emsp;&emsp;对于一次IO访问（这回以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的缓冲区，最后交给进程。所以说，当一个read操作发生时，它会<strong>经历两个阶段</strong>：</p><ul><li>等待数据准备 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li></ul><p>因为这两个阶段，linux系统产生了下面五种网络I/O的模式：</p><ul><li>阻塞 I/O（blocking IO）</li><li>非阻塞 I/O（nonblocking IO）</li><li>I/O 多路复用（ IO multiplexing）</li><li>信号驱动 I/O（ signal driven IO）</li><li>异步 I/O（asynchronous IO）<br>信号驱动在实际中并不常用，所以只讨论其他四种</li></ul><h4 id="Block-I-O-模型（阻塞I-O）"><a href="#Block-I-O-模型（阻塞I-O）" class="headerlink" title="Block I/O 模型（阻塞I/O）"></a>Block I/O 模型（阻塞I/O）</h4><p><img src="https://8090lambert.cn/images/blog/io/03.png" alt="阻塞I/O模型"><br>&emsp;&emsp;还是以read为例子</p><ul><li>进程发起 read，进行 recvfrom 系统调用；</li><li>内核开始第一阶段，准备数据（从磁盘拷贝到缓冲区），进程请求的数据并不是一下就能准备好；准备数据是要消耗时间的；</li><li>与此同时，进程阻塞（进程是自己选择阻塞与否），等待数据ing；</li><li>直到数据从内核拷贝到了用户空间，内核返回结果，进程解除阻塞。</li></ul><p>也就是说，<strong>内核准备数据和数据从内核拷贝到进程内存地址</strong>这两个过程都是阻塞的。</p><h4 id="None-Block-I-O-模型（非阻塞I-O）"><a href="#None-Block-I-O-模型（非阻塞I-O）" class="headerlink" title="None-Block I/O 模型（非阻塞I/O）"></a>None-Block I/O 模型（非阻塞I/O）</h4><p>&emsp;&emsp;可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src="https://8090lambert.cn/images/blog/io/04.png" alt="非阻塞I/O"></p><ul><li>当用户进程发出 <code>read</code> 操作时，如果 <code>Kernel</code> 中的数据还没有准备好；</li><li>那么它并不会 block 用户进程，而是立刻返回一个 error，从用户进程角度讲 ，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果；</li><li>用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 <code>system call</code>；</li><li>那么它马上就将数据拷贝到了用户内存，然后返回。</li></ul><p>Non-Block IO的特点是用户进程在内核准备数据的阶段<strong>需要不断的主动询问</strong>数据好了没有。</p><h4 id="Multiplexing-I-O-多路复用I-O"><a href="#Multiplexing-I-O-多路复用I-O" class="headerlink" title="Multiplexing I/O (多路复用I/O)"></a>Multiplexing I/O (多路复用I/O)</h4><p>&emsp;&emsp;I/O多路复用实际上就是用select, poll, epoll监听多个io对象，当io对象有变化（有数据）的时候就通知用户进程。好处就是单个进程可以处理多个socket。当然具体区别我们后面再讨论，现在先来看下I/O多路复用的流程：<br><img src="https://8090lambert.cn/images/blog/io/05.png" alt="I/O多路复用模型"></p><ul><li>当用户进程调用了 select，那么整个进程会被 block；</li><li>而同时，kernel 会“监视”所有 select 负责的 socket；</li><li>当任何一个 socket 中的数据准备好了，select就会返回;</li><li>这个时候用户进程再调用 read 操作，将数据从 kernel 拷贝到用户进程;<br>&emsp;&emsp;I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select() 函数就可以返回。<br>&emsp;&emsp;这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。<br>&emsp;&emsp;所以，<strong>如果处理的连接数不是很高的话，使用 select/epoll 的 web server 不一定比使用多线程 + 阻塞 IO的 web server 性能更好，可能延迟还更大</strong>。select/epoll 的优势<strong>并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</strong><br>在IO multiplexing Model中，实际中，对于每一个 socket，一般都设置成为 none-block，但是，如上图所示，整个用户的 process 其实是一直被 block 的。只不过 process 是被 select 这个函数 block，而不是被 socket IO 给 block (<strong>对应 epoll 的就是 epoll_wait() 会 block 住 process</strong>)。</li></ul><h4 id="Asynchronous-I-O（异步-I-O）"><a href="#Asynchronous-I-O（异步-I-O）" class="headerlink" title="Asynchronous I/O（异步 I/O）"></a>Asynchronous I/O（异步 I/O）</h4><p>异步 I/O 是真正做到了非阻塞，流程大概如下：<br><img src="https://8090lambert.cn/images/blog/io/06.png" alt=""></p><ul><li>用户进程发起read操作之后，立刻就可以开始去做其它的事。</li><li>而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。</li><li>然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。<br><br><br><br></li></ul><blockquote><p>Reference： <a href="https://www.cnblogs.com/wangyao2317072926/p/7918643.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangyao2317072926/p/7918643.html</a></p></blockquote></div><section class="comments" id="comments"><div id="gitment_thread"></div><link rel="stylesheet" href="//unpkg.com/gitment/style/default.css"><script src="//unpkg.com/gitment/dist/gitment.browser.js"></script><script>var gitment=new Gitment({id:"{{ page.date }}",owner:"8090Lambert",repo:"8090Lambert.github.io",oauth:{client_id:"b2e729afbaa762a4cecc",client_secret:"cb9b28cda56154edecbcf76d2ea66e5a0e12c209"}});gitment.render("comments")</script></section></div></div></div></article><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><p class="copyright text-muted"> &copy; 2016 - 2021<span class="with-love"><i class="fa fa-heart"></i></span> <span class="author">8090Lambert</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></p><p class="visit-statistics"> <span id="busuanzi_container_site_pv">本站总访问：<span id="busuanzi_value_site_pv"></span>次 &nbsp;&nbsp;&nbsp;&nbsp;</span></p><p></p></div></div></div></footer><script src="/js/highlight.pack.js"></script><script>document.addEventListener("DOMContentLoaded",function(e){Array.prototype.slice.call(document.getElementsByTagName("pre")).forEach(function(e,t){hljs.highlightBlock(e)})})</script></body></html>